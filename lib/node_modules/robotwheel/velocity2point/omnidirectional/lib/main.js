// MODULES //
var Float64Array = require( '@stdlib/array/float64' );
var sin  = require('@stdlib/math/base/special/sin');
var cos = require('@stdlib/math/base/special/cos');
var sqrt = require('@stdlib/math/base/special/sqrt');
var deg2rad = require('@stdlib/math/base/special/deg2rad');
var format = require( '@stdlib/string/format' );
var dgemm = require('@stdlib/blas/base/dgemm');
var dscal = require('@stdlib/blas/base/dscal');
var daxpy = require('@stdlib/blas/base/daxpy');

// MAIN //

/**
* Computes the final orientation of omnidirectional wheeled robots given wheel velocities of the robot.
*
* @param {PositiveInteger} radius - radius of the wheel (meters)
* @param {PositiveInteger} wheelbase - distance of the wheel from the center of the robot (meters)
* @param {number} x0 - initial position in x direction (meters)
* @param {number} y0 - initial position in y direction (meters)
* @param {number} psi0 - initial orientation of the robot (radians)
* @param {number} wheel_velocity_1 - angular velocity of first wheel (rad/s)
* @param {number} wheel_velocity_2 - angular velocity of second wheel (rad/s)
* @param {number} wheel_velocity_3 - angular velocity of third wheel (rad/s)
* @param {number} time - time taken to reach the final position (seconds)
*
* @example
* var omni_directional = require( 'robotwheel/velocity2point/omnidirectional' );
*
* var z = omni_directional( 0.1, 0.4, 0.0, 0.0, 0.0, 0.0, ~-4.33, ~4.33, 1.0 );
* // z => <Float64Array>[ 0.5, 0.0, 0.0 ]
*/
function omni_directional(radius, wheelbase, x0, y0, psi0, wheel_velocity_1, wheel_velocity_2, wheel_velocity_3, time) {
    var state_vector;
    var initial_state_vector;
    var initial_position_matrix;
    var rotation_matrix;
    var wheel_velocity_matrix;
    var transformation_matrix;

    psi0 = deg2rad( psi0 );

    wheel_velocity_matrix = new Float64Array( [ wheel_velocity_1, wheel_velocity_2, wheel_velocity_3 ] );

    initial_position_matrix = new Float64Array( [ x0, y0, psi0 ] );

    initial_state_vector = new Float64Array( 3 );

    state_vector = new Float64Array( 3 );

    if ( radius <= 0 ) {
        throw new RangeError( format( 'invalid argument. First argument must be a positive integer. Value: `%d`.', radius ) );
    }
    if ( wheelbase <= 0 ) {
        throw new RangeError( format( 'invalid argument. Second argument must be a positive integer. Value: `%d`.', wheelbase ) );
    }

    rotation_matrix = new Float64Array([
        cos(psi0), -sin(psi0), 0,
        sin(psi0), cos(psi0), 0,
        0, 0, 1
    ]);

    transformation_matrix = new Float64Array([
        0, -sqrt( 3 ), sqrt( 3 ),
        2, -1, -1,
        ( 1 / wheelbase ), ( 1 / wheelbase ), ( 1 / wheelbase )
    ]);

    dgemm('row-major', 'no-transpose', 'no-transpose',
        3, 1, 3,
        1,
        transformation_matrix, 3,
        wheel_velocity_matrix, 1,
        0,
        initial_state_vector, 1);

    dscal( 3, radius / 3, initial_state_vector, 1 );

    dgemm('row-major', 'no-transpose', 'no-transpose',
        3, 1, 3,
        1,
        rotation_matrix, 3,
        initial_state_vector, 1,
        0,
        state_vector, 1);

    dscal( 3, time, state_vector, 1 );

    daxpy( 3, 1, initial_position_matrix, 1, state_vector, 1 );

    return state_vector;
}
console.log(omni_directional(0.1,0.4,0,0,0,0, -4.330127018922193, 4.330127018922193,1));



// EXPORTS //
module.exports = omni_directional;