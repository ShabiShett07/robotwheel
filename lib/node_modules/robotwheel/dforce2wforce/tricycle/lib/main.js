// MODULES //
var Float64Array = require( '@stdlib/array/float64' );
var sin  = require('@stdlib/math/base/special/sin');
var cos = require('@stdlib/math/base/special/cos');
var deg2rad = require('@stdlib/math/base/special/deg2rad');
var format = require( '@stdlib/string/format' );
var dgemm = require('@stdlib/blas/base/dgemm');

// MAIN //

/**
* Computes the resultant forces of tricycle wheeled robots given the applied wheel forces.
*
* @param {PositiveInteger} wheelbase - distance between front wheel and rear wheels (meters)
* @param {number} f1 - applied force on front wheel (Newton)
* @param {number} theta - rotation of the front wheel ( degrees )
*
* @example
* var tricycle = require( 'robotwheel/dforce2wforce/tricycle' );
*
* var z = tricycle( 5.0, 2.0, 360.0 );
* // z => <Float64Array>[ 2.0, 0.0, 0.0 ]
*/
function tricycle(wheelbase, f1, theta ) {
    var wheel_force_vector;
    var transformation_matrix;
    var directional_force_vector;

    wheel_force_vector = new Float64Array([f1]);

    if ( wheelbase <= 0 ) {
        throw new RangeError( format( 'invalid argument. First argument must be a positive integer. Value: `%d`.', wheelbase ) );
    }

    theta = deg2rad( theta );

    directional_force_vector = new Float64Array( 3 );

    transformation_matrix = new Float64Array([
        cos( theta ),
        0,
        wheelbase*sin( theta )
    ]);

    dgemm('row-major', 'no-transpose', 'no-transpose',
        3, 1, 1,
        1,
        transformation_matrix, 1,
        wheel_force_vector, 1,
        0,
        directional_force_vector, 1);

    return directional_force_vector;
}


// EXPORTS //

module.exports = tricycle;
