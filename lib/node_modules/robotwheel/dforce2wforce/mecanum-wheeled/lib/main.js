// MODULES //
var Float64Array = require( '@stdlib/array/float64' );
var sqrt = require( '@stdlib/math/base/special/sqrt' );
var format = require( '@stdlib/string/format' );
var dgemm = require('@stdlib/blas/base/dgemm');
var dscal = require('@stdlib/blas/base/dscal');

// MAIN //

/**
* Computes the resultant forces of mecanum wheeled robots given the applied wheel forces.
*
* @param {PositiveInteger} wheelbase - distance between the left and right wheels (meters)
* @param {PositiveInteger} trackwidth - distance between the front and rear wheels (meters)
* @param {number} f1 - applied force on wheel 1 (Newton)
* @param {number} f2 - applied force on wheel 2 (Newton)
* @param {number} f3 - applied force on wheel 3 (Newton)
* @param {number} f4 - applied force on wheel 4 (Newton)
*
* @example
* var mecanum_wheeled = require( 'robotwheel/dforce2wforce/mecanum-wheeled' );
* var sqrt = require( '@stdlib/math/base/special/sqrt' );
*
* var z = mecanum_wheeled( 5.0, 5.0, 5.0 * sqrt( 2.0 ), 5.0 * sqrt( 2.0 ), 5.0 * sqrt( 2.0 ), 5.0 * sqrt( 2.0 ) );
* // z => <Float64Array>[ 20.0, 0.0, 0.0 ]
*/
function mecanum_wheeled( wheelbase, trackwidth, f1, f2, f3, f4 ) {
    var wheel_force_vector;
    var transformation_matrix;
    var directional_force_vector;
    var l;
    var d;

    if ( wheelbase <= 0 ) {
        throw new RangeError( format( 'invalid argument. First argument must be a positive integer. Value: `%d`.', wheelbase ) );
    }
    if ( trackwidth <= 0 ) {
        throw new RangeError( format( 'invalid argument. Second argument must be a positive integer. Value: `%d`.', trackwidth ) );
    }

    l = wheelbase / 2;

    d = trackwidth / 2;

    wheel_force_vector = new Float64Array([f1, f2, f3, f4]);

    directional_force_vector = new Float64Array( 3 );

    transformation_matrix = new Float64Array([
        1, 1, 1, 1,
        1, -1, 1, -1,
        l - d, l - d, -( l - d ), -( l - d )
    ]);

    dgemm('row-major', 'no-transpose', 'no-transpose',
        3, 1, 4,
        1,
        transformation_matrix, 4,
        wheel_force_vector, 1,
        0,
        directional_force_vector, 1);

    dscal( 3, ( 1 / sqrt(2) ), directional_force_vector, 1 );

    return directional_force_vector;
}


// EXPORTS //
module.exports = mecanum_wheeled;
