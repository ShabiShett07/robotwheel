// MODULES //
var Float64Array = require( '@stdlib/array/float64' );
var sin  = require('@stdlib/math/base/special/sin');
var cos = require('@stdlib/math/base/special/cos');
var deg2rad = require('@stdlib/math/base/special/deg2rad');
var format = require( '@stdlib/string/format' );
var dgemm = require('@stdlib/blas/base/dgemm');
var dscal = require('@stdlib/blas/base/dscal');

// MAIN //

/**
* Computes the wheel velocities of mecanum wheeled robots given final orientation of the robot.
*
* @param {PositiveInteger} radius - radius of the wheel (meters)
* @param {PositiveInteger} wheelbase - distance between the left and right wheels (meters)
* @param {PositiveInteger} trackwidth - distance between the front and rear wheels (meters)
* @param {number} x0 - initial position in x direction (meters)
* @param {number} y0 - initial position in y direction (meters)
* @param {number} psi0 - initial orientation of the robot (degrees)
* @param {number} x1 - final position in x direction (meters)
* @param {number} y1 - finial position in y direction (meters)
* @param {number} psi1 - final orientation of the robot (degrees)
* @param {number} time - time taken to reach the final position (seconds)
*
* @example
* var mecanum_wheeled = require( 'robotwheel/point2velocity/mecanum-wheeled' );
*
* var z = mecanum_wheeled( 0.1, 1.0, 0.8, 0.0, 0.0, 0.0, 1.0, 0.5, 0.0, 1.0 );
* // z => <Float64Array>[ 5.0, 15.0, 5.0, 15.0 ]
*/
function mecanum_wheeled(radius, wheelbase, trackwidth, x0, y0, psi0, x1, y1, psi1, time) {
    var xd;
    var yd;
    var psid;
    var global_velocity_vector;
    var rotation_matrix;
    var local_velocity_vector;
    var transformation_matrix;
    var initial_velocity_vector;
    var d;
    var l;

    psi0 = deg2rad( psi0 );
    psi1 = deg2rad( psi1 );

    l = wheelbase / 2;
    d = trackwidth / 2;

    if ( radius <= 0 ) {
        throw new RangeError( format( 'invalid argument. First argument must be a positive integer. Value: `%d`.', radius ) );
    }
    if ( wheelbase <= 0 ) {
        throw new RangeError( format( 'invalid argument. Second argument must be a positive integer. Value: `%d`.', wheelbase ) );
    }
    if ( trackwidth <= 0 ) {
        throw new RangeError( format( 'invalid argument. Third argument must be a positive integer. Value: `%d`.', trackwidth ) );
    }

    xd = (x1 - x0) / time;
    yd = (y1 - y0) / time;
    psid = (psi1 - psi0) / time;

    initial_velocity_vector = new Float64Array( 3 );
    global_velocity_vector = new Float64Array( 4 );

    rotation_matrix = new Float64Array([
        cos(psi0), sin(psi0), 0,
        -sin(psi0), cos(psi0), 0,
        0, 0, 1
    ]);

    local_velocity_vector = new Float64Array([xd, yd, psid]);

    transformation_matrix = new Float64Array([
        1, -1, -( l + d ),
        1, 1, -( l + d ),
        1, -1, ( l + d ),
        1, 1, ( l + d ),
    ]);

    dgemm('row-major', 'no-transpose', 'no-transpose',
        3, 1, 3,
        1,
        rotation_matrix, 3,
        local_velocity_vector, 1,
        0,
        initial_velocity_vector, 1);

    dgemm('row-major', 'no-transpose', 'no-transpose',
        4, 1, 3,
        1,
        transformation_matrix, 3,
        initial_velocity_vector, 1,
        0,
        global_velocity_vector, 1);

    global_velocity_vector = dscal( 4, ( 1 / radius ), global_velocity_vector, 1 );

    return global_velocity_vector;
}

// YOUR CUSTOM INPUTS //
// wheel_velocity = mecanum_wheeled( 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ); // Add your inputs here
// console.log( "Velocity of wheel 1: " + wheel_velocity[ 0 ] + " rad/s" );
// console.log( "Velocity of wheel 2: " + wheel_velocity[ 1 ] + " rad/s" );
// console.log( "Velocity of wheel 3: " + wheel_velocity[ 2 ] + " rad/s" );
// console.log( "Velocity of wheel 4: " + wheel_velocity[ 3 ] + " rad/s" );


// EXPORTS //
module.exports = mecanum_wheeled;